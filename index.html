<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Puzzle 108 pi√®ces (9√ó12) ‚Äì 4/3 portrait</title>
  <style>
    :root {
      --cols: 9;
      --rows: 12;
      /* Portrait 3:4 (width/height = 3/4) car 9/12 = 3/4 */
      --board-h: min(86vh, 960px);
      --board-w: calc(var(--board-h) * var(--cols) / var(--rows));
      --cell: calc(var(--board-w) / var(--cols));
    }

    * {
      box-sizing: border-box
    }

    body {
      margin: 0;
      min-height: 100svh;
      display: grid;
      grid-template-rows: auto 1fr auto;
      background: #0e0f13;
      color: #e8eaed;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, sans-serif
    }

    header {
      position: sticky;
      top: 0;
      z-index: 10;
      background: #12141a;
      border-bottom: 1px solid #23252b;
      padding: 12px clamp(12px, 3vw, 24px);
      display: flex;
      gap: 10px;
      align-items: center
    }

    header h1 {
      margin: 0 8px 0 0;
      font-size: clamp(16px, 2.4vw, 22px);
      font-weight: 650
    }

    .btn {
      background: #2c68ff;
      color: #fff;
      border: 0;
      padding: 10px 14px;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer
    }

    .btn.secondary {
      background: #2b2f3a;
      color: #e8eaed
    }

    main {
      display: grid;
      grid-template-columns: var(--board-w) minmax(360px, 560px);
      gap: 18px;
      align-items: start;
      padding: 16px clamp(12px, 3vw, 24px)
    }

    @media (max-width:980px) {
      main {
        grid-template-columns: 1fr
      }
    }

    .board {
      position: relative;
      width: var(--board-w);
      height: var(--board-h);
      background: #0b0c10;
      border-radius: 16px;
      outline: 1px solid #23252b;
      overflow: hidden;
      user-select: none;
      touch-action: none;
      box-shadow: inset 0 8px 30px rgba(0, 0, 0, .35), 0 10px 30px rgba(0, 0, 0, .2)
    }

    .grid-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background-image:
        linear-gradient(to right, rgba(255, 255, 255, .06) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(255, 255, 255, .06) 1px, transparent 1px);
      background-size:
        calc(var(--board-w)/var(--cols)) var(--board-h),
        var(--board-w) calc(var(--board-h)/var(--rows));
    }

    .sidebar {
      position: sticky;
      top: 84px;
      display: grid;
      gap: 14px;
      align-content: start
    }

    .preview {
      aspect-ratio: 3 / 4;
      height: auto;
      min-height: 220px;
      border-radius: 12px;
      outline: 1px solid #23252b;
      background: #090a0f center/contain no-repeat
    }

    .progress {
      display: flex;
      justify-content: space-between;
      background: #141722;
      outline: 1px solid #23252b;
      padding: 10px 12px;
      border-radius: 12px;
      font-variant-numeric: tabular-nums
    }

    .tray {
      position: relative;
      height: 72vh;
      background: #141722;
      outline: 1px solid #23252b;
      border-radius: 16px;
      box-shadow: inset 0 10px 30px rgba(0, 0, 0, .2);
      overflow: auto;
      padding: 12px
    }

    .tray-inner {
      position: relative;
      min-height: 100%
    }

    .piece {
      position: absolute;
      cursor: grab;
      filter: drop-shadow(0 0 0.6px rgba(0, 0, 0, .55)) drop-shadow(0 6px 10px rgba(0, 0, 0, .4));
      background-repeat: no-repeat;
      transition: opacity .15s ease;
      will-change: left, top
    }

    .piece:active {
      cursor: grabbing
    }

    .piece.locked {
      filter: drop-shadow(0 2px 6px rgba(0, 0, 0, .35));
      cursor: default
    }

    footer {
      padding: 10px 16px;
      text-align: center;
      font-size: 13px;
      opacity: .8;
      border-top: 1px solid #23252b;
      background: #12141a
    }
  </style>
</head>

<body>
  <header>
    <h1>üß© Puzzle 108 pi√®ces</h1>
    <button id="changeBg" class="btn secondary">Changer le puzzle</button>
    <button id="shuffle" class="btn">M√©langer</button>
    <label style="margin-left:12px; display:flex; align-items:center; gap:6px; font-size:14px; opacity:.9">
      <input id="autoLockToggle" type="checkbox" checked /> Verrouillage auto (pi√®ces bien plac√©es)
    </label>
  </header>

  <main>
    <div class="board" id="board" aria-label="Plateau du puzzle" role="application">
      <div class="grid-overlay"></div>
    </div>
    <aside class="sidebar">
      <div id="preview" class="preview" aria-label="Aper√ßu de l'image"></div>
      <div class="progress"><span>Plac√©es</span><strong><span id="count">0</span>/<span id="total">108</span></strong>
      </div>
      <div class="tray" id="tray" aria-label="Bac de pi√®ces (faites glisser)">
        <div class="tray-inner" id="trayInner"></div>
      </div>
    </aside>
  </main>

  <footer>Plateau 4/3 en <strong>portrait</strong> (9√ó12 = 108 pi√®ces).</footer>

  <script>
    // --- Config ---
    const COLS = 9, ROWS = 12, TOTAL = COLS * ROWS;
    const board = document.getElementById('board');
    const tray = document.getElementById('tray');
    const trayInner = document.getElementById('trayInner');
    const preview = document.getElementById('preview');
    const shuffleBtn = document.getElementById('shuffle');
    const changeBgBtn = document.getElementById('changeBg');
    const countEl = document.getElementById('count');
    const totalEl = document.getElementById('total');
    const autoLockToggle = document.getElementById('autoLockToggle');
    totalEl.textContent = String(TOTAL);
    let autoLock = true;

    // üîó 4 URLs d'images modifiables
    const images = [
      'https://ucedbe94df42cda94d5f10a3fd95.previews.dropboxusercontent.com/p/thumb/AC0G3CV2dHBgb_iar_JIJxfHlACLFvKKBnCIWDz00TT33HJm1Y_YMbQTLGla3tQbgM35zfmWAbBTHs18ugEqnll8_Tyl5y5RufqVcsuQQJSHJDlH7mkqQDuUQnX4Zvh5QaemY9Azbg_t8_9--EgusYvHnGHW9Eu1kA23SD2Ekp94sCPCVzrsQT-6PTt7gD_qkx1jiDP8_luEYWK_SP_Hwp4uGWhYk_kmg99gPSJlxipaGp9c5dILaJ97z4GHc_wGvz0O6ojJdla-WwaKTudA3rzCjcKIc3b3mT2k7Z5fRvlnusNG0d_OqHsNNJd8SJ_jMTipqnqSoDLtPXEJpi0_H9EtxzRSLmft205CB2EQu2YXFks3y5zAZebiLkgp7TqjGzIZA5PK1UbC6SyxvAj0Hk3q/p.png?is_prewarmed=true',
      'https://uc6f7a7b88d0d4fcab97593c3d8e.previews.dropboxusercontent.com/p/thumb/AC0sxGELV4QgKhqPwdEyO5Qqfxs8vnLSw2pzw0JCz--pm_scRm-Pa05OS-zAmfV_BMx2GL2WVOOrEKHI3hCLBBE4VzPKd6r9x-yK7h3h-stP9FoHr-BM3tIacP4PWbWX-kEBdaeKikZhjm8afyWp9zm8wOO82I7vykHi5C_T3puXP4haBg36bksq7qzpak2LrjiEwOdGzb0pSp5sX5eHWYdgCD6qKkkfg874ngWyeQMC1zXsYhrZ91mATnXgpO4BZEqugn-Rs90RDM6wDRsMon7bAjHFDgfKjEERSpl9SXCHWimFsFvWF478z4vIK3nBKvcF4ptxVUkhuOm-JrBwZEA531Oj-FcbPKEMm9wlnhum0JWW9TVLlA_6EfhRaeVqfdjhZdGFfhp1aev0WHGBsvcD/p.png?is_prewarmed=true',
      'https://uc8341f0f8a0f5da2df5bf320837.previews.dropboxusercontent.com/p/thumb/AC1bI0XAKBuj9p0NP_K-RdPxN0pC3U6G_eQdf5czIYAYaDj77_Lg8__4EdywgYB9TjGDU8fT5uBJRTv4hrVgtQPtMo1M_VcsPJY-CYIQIBHwsxCtEVP3LjpaThu0CZUcZsGEE4qkeNfRPLcUK7sHCgSMUta71MaQiEEuzb_0qx52E4nxqvORzmsQ3jdzllBk0xUBP-CJIJsCG-7fOcGapl6_Wbb8_eU5HQvKg8IY-v3MDvFp25MUlzKVMPzAAGy18TgyZSzlczSwKE67_dQi7T8q7j_LtfNbmcpSeBqQOiNoQfUGLGTmIM7sogy7icnpk7RJgtMGCadE6hMAvKxeCR1soyp7ds_nJ8sILBIJ01UQOA7Bqr3r_ZMAML3MjNRJ5zzaZyWpi5F0qpm_5zxZlpce/p.png?is_prewarmed=true',
      'https://ucc06edc97d97866d89455b70417.previews.dropboxusercontent.com/p/thumb/AC1WZ40DjXb6s7B768bBvW-eYxDGVsSmwNTLA-sPaGBKcjapiOWM89uujenCjDTc6-AnhmJA2xYT4iw1QceBXGDn3HafOzcH8kiZl3K22C-4sMOym7wHGjbeU9zGpcCiXgFyqEZkX-bDGbqCdM38ML8atpxiTvSoX02kdOpJVMWIoBDDcnlNLCg64Kcp8tX-z0fOkeJUbjgY3c3_52UM01dnEXrdCO3SnMjAJt1X4gVq2IvGuzZyJHVoOlR1tLubjp5g4ab_6x8vy4A6gyeC9YyT4vGuj2peD6Qxp24-11c6eCCyc2slWpqtlvJkeYDOn7YipPQLHpahxyhT6MzK2bQloPsituSlid6crUaYQeTpluguvS9mwkNGDf-rawqoirOC6qYDqT-lN3x7KbiwYujA/p.png?is_prewarmed=true'
    ];

    let currentImageIndex = 0;
    let imgURL = images[0], cell = 0, placedCount = 0;
    let pieces = [], occupied = new Map();

    // Edge maps (tenon/creux)
    const H = Array.from({ length: ROWS }, () => Array(COLS - 1).fill(0));
    const V = Array.from({ length: ROWS - 1 }, () => Array(COLS).fill(0));

    function setMetrics() {
      cell = board.getBoundingClientRect().width / COLS;
      document.documentElement.style.setProperty('--cell', cell + 'px');
    }
    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
    function genEdges() {
      for (let r = 0; r < ROWS; r++)
        for (let c = 0; c < COLS - 1; c++)
          H[r][c] = Math.random() > .5 ? 1 : -1;
      for (let r = 0; r < ROWS - 1; r++)
        for (let c = 0; c < COLS; c++)
          V[r][c] = Math.random() > .5 ? 1 : -1;
    }

    // --- Forme des pi√®ces (stable) ---
    function piecePath(r, c) {
      const s = cell, bleed = s * .22, k = s * .18, t = s * .35;
      const EPS = Math.max(0.75, s * 0.0025);
      const signTop = (r === 0) ? 0 : -V[r - 1][c];
      const signRight = (c === COLS - 1) ? 0 : H[r][c];
      const signBottom = (r === ROWS - 1) ? 0 : V[r][c];
      const signLeft = (c === 0) ? 0 : -H[r][c - 1];
      const X = x => x + bleed, Y = y => y + bleed;

      function topEdge(sign) {
        if (sign === 0) return [['L', X(s + EPS), Y(-EPS)]];
        const mid = s / 2, h = t * sign, cp = k;
        return [
          ['L', X(mid - k), Y(-EPS)],
          ['C', X(mid - cp), Y(-EPS), X(mid - cp), Y(h), X(mid), Y(h)],
          ['C', X(mid + cp), Y(h), X(mid + cp), Y(-EPS), X(mid + k), Y(-EPS)],
          ['L', X(s + EPS), Y(-EPS)]
        ];
      }
      function rightEdge(sign) {
        if (sign === 0) return [['L', X(s + EPS), Y(s + EPS)]];
        const mid = s / 2, h = t * sign, cp = k;
        return [
          ['L', X(s + EPS), Y(mid - k)],
          ['C', X(s + EPS), Y(mid - cp), X(s + h), Y(mid - cp), X(s + h), Y(mid)],
          ['C', X(s + h), Y(mid + cp), X(s + EPS), Y(mid + cp), X(s + EPS), Y(mid + k)],
          ['L', X(s + EPS), Y(s + EPS)]
        ];
      }
      function bottomEdge(sign) {
        if (sign === 0) return [['L', X(-EPS), Y(s + EPS)]];
        const mid = s / 2, h = t * sign, cp = k;
        return [
          ['L', X(s - (mid - k)), Y(s + EPS)],
          ['C', X(s - (mid - cp)), Y(s + EPS), X(s - (mid - cp)), Y(s + h), X(s - mid), Y(s + h)],
          ['C', X(s - (mid + cp)), Y(s + h), X(s - (mid + cp)), Y(s + EPS), X(s - (mid + k)), Y(s + EPS)],
          ['L', X(-EPS), Y(s + EPS)]
        ];
      }
      function leftEdge(sign) {
        if (sign === 0) return [['L', X(-EPS), Y(-EPS)]];
        const mid = s / 2, h = t * sign, cp = k;
        return [
          ['L', X(-EPS), Y(s - (mid - k))],
          ['C', X(-EPS), Y(s - (mid - cp)), X(-h), Y(s - (mid - cp)), X(-h), Y(s - mid)],
          ['C', X(-h), Y(s - (mid + cp)), X(-EPS), Y(s - (mid + cp)), X(-EPS), Y(s - (mid + k))],
          ['L', X(-EPS), Y(-EPS)]
        ];
      }

      const cmds = [
        ['M', X(-EPS), Y(-EPS)],
        ...topEdge(signTop),
        ...rightEdge(signRight),
        ...bottomEdge(signBottom),
        ...leftEdge(signLeft)
      ];
      let d = '';
      for (const c2 of cmds) d += c2[0] + ' ' + c2.slice(1).join(' ') + ' ';
      d += 'Z';
      return d;
    }

    function createPiece(r, c, url) {
      const el = document.createElement('div');
      el.className = 'piece';
      el.dataset.index = r * COLS + c;
      el.dataset.row = r; el.dataset.col = c;
      const bleed = cell * .3, elW = cell + 2 * bleed;
      el.style.width = elW + 'px'; el.style.height = elW + 'px';
      const x = 12 + Math.random() * Math.max(12, (tray.clientWidth - elW - 36));
      const y = 12 + Math.random() * Math.max(12, (tray.clientHeight * 2 - elW - 36));
      el.style.left = x + 'px'; el.style.top = y + 'px'; el.style.position = 'absolute';
      trayInner.appendChild(el);

      el.style.backgroundImage = `url('${url}')`; el.style.backgroundRepeat = 'no-repeat';
      el.style.backgroundSize = `${COLS * cell}px ${ROWS * cell}px`;
      el.style.backgroundPosition = `${-c * cell + bleed}px ${-r * cell + bleed}px`;

      const path = piecePath(r, c);
      el.style.clipPath = `path('${path}')`;
      el.style.webkitClipPath = `path('${path}')`;

      makeDraggable(el);
      pieces.push(el);
    }

    function makeDraggable(el) {
      let drag = false, offX = 0, offY = 0, startRect = null, prevPos = null;

      el.addEventListener('pointerdown', e => {
        if (el.classList.contains('locked') && !e.altKey) return;

        drag = true;
        el.setPointerCapture(e.pointerId);

        // Position √©cran *avant* de changer de conteneur
        startRect = el.getBoundingClientRect();
        offX = e.clientX - startRect.left;
        offY = e.clientY - startRect.top;

        // √âvite le "saut" : on passe en fixed aux m√™mes coordonn√©es √©cran
        document.body.appendChild(el);
        el.style.position = 'fixed';
        el.style.left = startRect.left + 'px';
        el.style.top = startRect.top + 'px';
        el.style.zIndex = 20;
        el.style.opacity = .96;

        prevPos = { left: startRect.left, top: startRect.top };
      });

      window.addEventListener('pointermove', e => {
        if (!drag) return;
        const nx = e.clientX - offX;
        const ny = e.clientY - offY;
        if (!prevPos || prevPos.left !== nx || prevPos.top !== ny) {
          el.style.left = nx + 'px';
          el.style.top = ny + 'px';
          prevPos = { left: nx, top: ny };
        }
      });

      window.addEventListener('pointerup', e => {
        if (!drag) return;
        drag = false;
        el.releasePointerCapture(e.pointerId);
        el.style.zIndex = '';
        el.style.opacity = 1;

        // Lib√®re l‚Äô√©ventuelle case occup√©e par cette pi√®ce
        const prev = el.dataset.posIdx;
        if (prev && occupied.get(+prev) === el) occupied.delete(+prev);

        const bcr = board.getBoundingClientRect();
        const cx = e.clientX - offX + el.offsetWidth / 2;
        const cy = e.clientY - offY + el.offsetHeight / 2;
        const insideBoard = (cx >= bcr.left && cx <= bcr.right && cy >= bcr.top && cy <= bcr.bottom);

        if (insideBoard) {
          // D√©p√¥t dans le plateau (coordonn√©es relatives)
          const localX = cx - bcr.left;
          const localY = cy - bcr.top;
          const col = clamp(Math.round(localX / cell - 0.5), 0, COLS - 1);
          const row = clamp(Math.round(localY / cell - 0.5), 0, ROWS - 1);
          const idx = row * COLS + col;

          if (occupied.has(idx)) {
            // Case d√©j√† occup√©e ‚Üí retour bac
            returnToTray(el);
          } else {
            board.appendChild(el);
            el.style.position = 'absolute';
            const bleed = (el.offsetWidth - cell) / 2;
            el.style.left = (col * cell - bleed) + 'px';
            el.style.top = (row * cell - bleed) + 'px';
            el.dataset.posIdx = idx;
            occupied.set(idx, el);

            if (autoLock && +el.dataset.index === idx) {
              el.classList.add('locked');
              placedCount++;
              updateProgress();
            }
          }
        } else {
          // Hors plateau ‚Üí retour bac
          returnToTray(el);
        }
      });

      // Double-clic : d√©verrouiller
      el.addEventListener('dblclick', () => {
        if (el.classList.contains('locked')) {
          el.classList.remove('locked');
          const prev = el.dataset.posIdx;
          if (prev && occupied.get(+prev) === el) occupied.delete(+prev);
        }
      });
    }


    function returnToTray(el) {
      // Toujours revenir en absolute dans le bac
      el.classList.remove('locked');
      el.style.position = 'absolute';
      el.style.zIndex = '';
      el.style.opacity = 1;

      // Oublier l‚Äôemplacement sur le plateau
      const prev = el.dataset.posIdx;
      if (prev && occupied.get(+prev) === el) occupied.delete(+prev);
      el.dataset.posIdx = '';

      trayInner.appendChild(el);

      // Repositionnement al√©atoire dans le bac
      const bleed = (el.offsetWidth - cell) / 2;
      const elW = cell + 2 * bleed;
      const maxX = Math.max(12, (tray.clientWidth - elW - 36));
      const maxY = Math.max(12, (tray.clientHeight * 2 - elW - 36)); // zone scrollable
      const x = 12 + Math.random() * maxX;
      const y = 12 + Math.random() * maxY;
      el.style.left = x + 'px';
      el.style.top = y + 'px';
    }


    function updateProgress() { countEl.textContent = String(placedCount); }

    function shufflePieces() {
      pieces.forEach(p => { p.classList.remove('locked'); p.dataset.posIdx = ''; });
      occupied.clear(); placedCount = 0; updateProgress();
      pieces.forEach(p => returnToTray(p));
    }

    function rebuild(url) {
      pieces.forEach(p => p.remove());
      pieces = []; occupied.clear(); placedCount = 0; updateProgress();
      setMetrics(); genEdges();
      for (let r = 0; r < ROWS; r++)
        for (let c = 0; c < COLS; c++)
          createPiece(r, c, url);
    }

    function changeBackground() {
      currentImageIndex = (currentImageIndex + 1) % images.length;
      imgURL = images[currentImageIndex];
      preview.style.backgroundImage = `url('${imgURL}')`;
      rebuild(imgURL);
    }

    window.addEventListener('resize', () => {
      setMetrics();
      const bleedCalc = p => (p.offsetWidth - cell) / 2;
      pieces.forEach(p => {
        if (p.classList.contains('locked')) {
          const idx = +p.dataset.posIdx;
          if (Number.isFinite(idx)) {
            const row = Math.floor(idx / COLS), col = idx % COLS;
            const bleed = bleedCalc(p);
            p.style.left = (col * cell - bleed) + 'px';
            p.style.top = (row * cell - bleed) + 'px';
            board.appendChild(p);
          }
        }
      });
    });

    (function init() {
      const imgURLInit = images[0];
      preview.style.backgroundImage = `url('${imgURLInit}')`;
      setMetrics(); genEdges(); rebuild(imgURLInit);
    })();

    shuffleBtn.addEventListener('click', shufflePieces);
    changeBgBtn.addEventListener('click', changeBackground);
    autoLockToggle.addEventListener('change', () => { autoLock = autoLockToggle.checked; });
  </script>
</body>

</html>
