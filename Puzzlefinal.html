<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Puzzle 100 pi√®ces (10√ó10) ‚Äì Bac agrandi</title>
  <style>
    :root {
      --board-size: min(76vmin, 720px);
      --cols: 10;
      --rows: 10;
      --cell: calc(var(--board-size) / var(--cols));
    }

    * {
      box-sizing: border-box
    }

    body {
      margin: 0;
      min-height: 100svh;
      display: grid;
      grid-template-rows: auto 1fr auto;
      background: #0e0f13;
      color: #e8eaed;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, sans-serif
    }

    header {
      position: sticky;
      top: 0;
      z-index: 10;
      background: #12141a;
      border-bottom: 1px solid #23252b;
      padding: 12px clamp(12px, 3vw, 24px);
      display: flex;
      gap: 10px;
      align-items: center
    }

    header h1 {
      margin: 0 8px 0 0;
      font-size: clamp(16px, 2.4vw, 22px);
      font-weight: 650
    }

    .btn {
      background: #2c68ff;
      color: #fff;
      border: 0;
      padding: 10px 14px;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer
    }

    .btn.secondary {
      background: #2b2f3a;
      color: #e8eaed
    }

    main {
      display: grid;
      grid-template-columns: var(--board-size) minmax(380px, 560px);
      gap: 18px;
      align-items: start;
      padding: 16px clamp(12px, 3vw, 24px)
    }

    @media (max-width:980px) {
      main {
        grid-template-columns: 1fr
      }
    }

    /* Board */
    .board {
      position: relative;
      width: var(--board-size);
      height: var(--board-size);
      background: #0b0c10;
      border-radius: 16px;
      outline: 1px solid #23252b;
      overflow: hidden;
      user-select: none;
      touch-action: none;
      box-shadow: inset 0 8px 30px rgba(0, 0, 0, .35), 0 10px 30px rgba(0, 0, 0, .2)
    }

    .grid-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background-image: linear-gradient(to right, rgba(255, 255, 255, .06) 1px, transparent 1px), linear-gradient(to bottom, rgba(255, 255, 255, .06) 1px, transparent 1px);
      background-size: calc(var(--board-size)/var(--cols)) var(--board-size), var(--board-size) calc(var(--board-size)/var(--rows))
    }

    /* Sidebar */
    .sidebar {
      position: sticky;
      top: 84px;
      display: grid;
      gap: 14px;
      align-content: start
    }

    .preview {
      height: 180px;
      border-radius: 12px;
      outline: 1px solid #23252b;
      background: #090a0f center/contain no-repeat
    }

    .progress {
      display: flex;
      justify-content: space-between;
      background: #141722;
      outline: 1px solid #23252b;
      padding: 10px 12px;
      border-radius: 12px;
      font-variant-numeric: tabular-nums
    }

    /* BIG tray */
    .tray {
      position: relative;
      height: 72vh;
      /* << beaucoup plus grand */
      background: #141722;
      outline: 1px solid #23252b;
      border-radius: 16px;
      box-shadow: inset 0 10px 30px rgba(0, 0, 0, .2);
      overflow: auto;
      padding: 12px
    }

    .tray-inner {
      position: relative;
      min-height: 100%;
    }

    .tray::webkit-scrollbar {
      width: 8px
    }

    /* Pieces */
    .piece {
      position: absolute;
      cursor: grab;
      filter: drop-shadow(0 0 0.6px rgba(0, 0, 0, .55)) drop-shadow(0 6px 10px rgba(0, 0, 0, .4));
      background-repeat: no-repeat;
      transition: opacity .15s ease
    }

    .piece:active {
      cursor: grabbing
    }

    .piece.locked {
      filter: drop-shadow(0 2px 6px rgba(0, 0, 0, .35));
      cursor: default
    }

    footer {
      padding: 10px 16px;
      text-align: center;
      font-size: 13px;
      opacity: .8;
      border-top: 1px solid #23252b;
      background: #12141a
    }
  </style>
</head>

<body>
  <header>
    <h1>üß© Puzzle 100 pi√®ces</h1>
    <label class="btn secondary" for="file">Importer une image</label>
    <input id="file" type="file" accept="image/*" style="display:none" />
    <button id="shuffle" class="btn">M√©langer</button>
    <label style="margin-left:12px; display:flex; align-items:center; gap:6px; font-size:14px; opacity:.9">
      <input id="autoLockToggle" type="checkbox" checked /> Verrouillage auto (pi√®ces bien plac√©es)
    </label>
  </header>

  <main>
    <div class="board" id="board" aria-label="Plateau du puzzle" role="application">
      <div class="grid-overlay"></div>
    </div>
    <aside class="sidebar">
      <div id="preview" class="preview" aria-label="Aper√ßu de l'image"></div>
      <div class="progress"><span>Plac√©es</span><strong><span id="count">0</span>/100</strong></div>
      <div class="tray" id="tray" aria-label="Bac de pi√®ces (faites glisser)">
        <div class="tray-inner" id="trayInner"></div>
      </div>
    </aside>
  </main>

  <footer>L'image ne s'affiche que dans l'aper√ßu. Le bac est agrandi pour voir toutes les pi√®ces.</footer>

  <script>
    // --- Config ---
    const COLS = 10, ROWS = 10, TOTAL = COLS * ROWS;
    const board = document.getElementById('board');
    const tray = document.getElementById('tray');
    const trayInner = document.getElementById('trayInner');
    const preview = document.getElementById('preview');
    const fileInput = document.getElementById('file');
    const shuffleBtn = document.getElementById('shuffle');
    const countEl = document.getElementById('count');
    const autoLockToggle = document.getElementById('autoLockToggle');
    let autoLock = true;

    let imgURL = null, cell = 0, placedCount = 0;
    let pieces = [], occupied = new Map();

    const defaultImage = 'https://media.discordapp.net/attachments/793132096494764065/1432319977922367518/ChatGPT_Image_Oct_27_2025_11_45_37_AM.png?ex=69009f6d&is=68ff4ded&hm=2e742f38ce1c5574d5d696efb228331b4375e72fdac6567c7c30901b3f7c731f&=&format=webp&quality=lossless&width=1956&height=1956';

    // Edge maps (tenon/creux)
    const H = Array.from({ length: ROWS }, () => Array(COLS - 1).fill(0));
    const V = Array.from({ length: ROWS - 1 }, () => Array(COLS).fill(0));

    function setMetrics() { cell = board.getBoundingClientRect().width / COLS; document.documentElement.style.setProperty('--cell', cell + 'px'); }
    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
    function genEdges() {
      for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS - 1; c++) H[r][c] = Math.random() > .5 ? 1 : -1;
      for (let r = 0; r < ROWS - 1; r++) for (let c = 0; c < COLS; c++) V[r][c] = Math.random() > .5 ? 1 : -1;
    }

    // --- Edge helpers ---
    function edgesForPieceOrigin(r0, c0) {
      return {
        top: (r0 === 0) ? 0 : -V[r0 - 1][c0],
        right: (c0 === COLS - 1) ? 0 : H[r0][c0],
        bottom: (r0 === ROWS - 1) ? 0 : V[r0][c0],
        left: (c0 === 0) ? 0 : -H[r0][c0 - 1],
      };
    }
    function requiredEdgesForCell(r, c) {
      return {
        top: (r === 0) ? 0 : -V[r - 1][c],
        right: (c === COLS - 1) ? 0 : H[r][c],
        bottom: (r === ROWS - 1) ? 0 : V[r][c],
        left: (c === 0) ? 0 : -H[r][c - 1],
      };
    }
    function edgesMatch(e1, e2) { return e1.top === e2.top && e1.right === e2.right && e1.bottom === e2.bottom && e1.left === e2.left; }

    function piecePath(r, c) {
      const s = cell, bleed = s * .22, k = s * .18, t = s * .35; // base
      const EPS = Math.max(0.75, s * 0.0025);
      const signTop = (r === 0) ? 0 : -V[r - 1][c];
      const signRight = (c === COLS - 1) ? 0 : H[r][c];
      const signBottom = (r === ROWS - 1) ? 0 : V[r][c];
      const signLeft = (c === 0) ? 0 : -H[r][c - 1];
      const X = x => x + bleed, Y = y => y + bleed;

      // Canonical TOP edge path from x=0->s (clockwise). We'll mirror for others.
      function topEdge(sign) {
        if (sign === 0) {
          return [
            ['L', X(s + EPS), Y(-EPS)]
          ];
        }
        const mid = s / 2, h = t * sign, cp = k;
        return [
          ['L', X(mid - k), Y(-EPS)],
          ['C', X(mid - cp), Y(-EPS), X(mid - cp), Y(h), X(mid), Y(h)],
          ['C', X(mid + cp), Y(h), X(mid + cp), Y(-EPS), X(mid + k), Y(-EPS)],
          ['L', X(s + EPS), Y(-EPS)]
        ];
      }

      // Mirror helpers
      const mirrorY = (cmd) => cmd.map((v, i) => (i % 2 ? v : v)).slice(); // placeholder (we keep X)
      function rightEdge(sign) {
        // rotate +90¬∞: swap (x,y)->(y,x) around (s,s)
        if (sign === 0) return [['L', X(s + EPS), Y(s + EPS)]];
        const mid = s / 2, h = t * sign, cp = k;
        return [
          ['L', X(s + EPS), Y(mid - k)],
          ['C', X(s + EPS), Y(mid - cp), X(s + h), Y(mid - cp), X(s + h), Y(mid)],
          ['C', X(s + h), Y(mid + cp), X(s + EPS), Y(mid + cp), X(s + EPS), Y(mid + k)],
          ['L', X(s + EPS), Y(s + EPS)]
        ];
      }
      function bottomEdge(sign) {
        if (sign === 0) return [['L', X(-EPS), Y(s + EPS)]];
        const mid = s / 2, h = t * sign, cp = k;
        return [
          ['L', X(s - (mid - k)), Y(s + EPS)],
          ['C', X(s - (mid - cp)), Y(s + EPS), X(s - (mid - cp)), Y(s + h), X(s - mid), Y(s + h)],
          ['C', X(s - (mid + cp)), Y(s + h), X(s - (mid + cp)), Y(s + EPS), X(s - (mid + k)), Y(s + EPS)],
          ['L', X(-EPS), Y(s + EPS)]
        ];
      }
      function leftEdge(sign) {
        if (sign === 0) return [['L', X(-EPS), Y(-EPS)]];
        const mid = s / 2, h = t * sign, cp = k;
        return [
          ['L', X(-EPS), Y(s - (mid - k))],
          ['C', X(-EPS), Y(s - (mid - cp)), X(-h), Y(s - (mid - cp)), X(-h), Y(s - mid)],
          ['C', X(-h), Y(s - (mid + cp)), X(-EPS), Y(s - (mid + cp)), X(-EPS), Y(s - (mid + k))],
          ['L', X(-EPS), Y(-EPS)]
        ];
      }

      const cmds = [['M', X(-EPS), Y(-EPS)], ...topEdge(signTop), ...rightEdge(signRight), ...bottomEdge(signBottom), ...leftEdge(signLeft)];
      // Build path string
      let d = '';
      for (const c of cmds) { d += c[0] + ' ' + c.slice(1).join(' ') + ' '; }
      d += 'Z';
      return d;
    }

    function createPiece(r, c, url) {
      const el = document.createElement('div'); el.className = 'piece'; el.dataset.index = r * COLS + c; el.dataset.row = r; el.dataset.col = c;
      const bleed = cell * .3, elW = cell + 2 * bleed; el.style.width = elW + 'px'; el.style.height = elW + 'px';
      // Random position inside big tray
      const tr = trayInner.getBoundingClientRect();
      const x = 12 + Math.random() * Math.max(12, (tray.clientWidth - elW - 36));
      const y = 12 + Math.random() * Math.max(12, (tray.clientHeight * 2 - elW - 36)); // g√©n√©re une grande zone scrollable
      el.style.left = x + 'px'; el.style.top = y + 'px'; el.style.position = 'absolute';
      trayInner.appendChild(el);

      // Background in pixels for perfect alignment
      el.style.backgroundImage = `url('${url}')`; el.style.backgroundRepeat = 'no-repeat';
      el.style.backgroundSize = `${COLS * cell}px ${ROWS * cell}px`;
      el.style.backgroundPosition = `${-c * cell + bleed}px ${-r * cell + bleed}px`;

      const path = piecePath(r, c); el.style.clipPath = `path('${path}')`; el.style.webkitClipPath = `path('${path}')`;
      makeDraggable(el);
      pieces.push(el);
    }

    function makeDraggable(el) {
      let drag = false, offX = 0, offY = 0, allowLockedDrag = false;
      el.addEventListener('pointerdown', e => {
        // Hold ALT (Option) to d√©placer une pi√®ce verrouill√©e
        if (el.classList.contains('locked') && !e.altKey) { return; }
        allowLockedDrag = e.altKey && el.classList.contains('locked');
        drag = true; el.setPointerCapture(e.pointerId); const r = el.getBoundingClientRect(); offX = e.clientX - r.left; offY = e.clientY - r.top; el.style.zIndex = 20; el.style.opacity = .96; document.body.appendChild(el);
      });
      window.addEventListener('pointermove', e => { if (!drag) return; el.style.left = (e.clientX - offX) + 'px'; el.style.top = (e.clientY - offY) + 'px'; });
      window.addEventListener('pointerup', e => {
        if (!drag) return; drag = false; el.releasePointerCapture(e.pointerId); el.style.zIndex = ''; el.style.opacity = 1;
        // free previous cell if any
        const prev = el.dataset.posIdx; if (prev && occupied.get(+prev) === el) occupied.delete(+prev);
        const bcr = board.getBoundingClientRect(); const cx = e.clientX - offX + el.offsetWidth / 2; const cy = e.clientY - offY + el.offsetHeight / 2;
        if (cx >= bcr.left && cx <= bcr.right && cy >= bcr.top && cy <= bcr.bottom) {
          const localX = cx - bcr.left; const localY = cy - bcr.top; const col = clamp(Math.round(localX / cell - 0.5), 0, COLS - 1); const row = clamp(Math.round(localY / cell - 0.5), 0, ROWS - 1); const idx = row * COLS + col;
          // If cell already occupied, cancel
          if (occupied.has(idx)) {
            returnToTray(el);
            return;
          }
          board.appendChild(el); const bleed = (el.offsetWidth - cell) / 2; el.style.left = (col * cell - bleed) + 'px'; el.style.top = (row * cell - bleed) + 'px'; el.dataset.posIdx = idx; occupied.set(idx, el);
          if (autoLock && +el.dataset.index === idx) { el.classList.add('locked'); placedCount++; updateProgress(); }
        } else { returnToTray(el); }
      });

      // Double-clic pour d√©verrouiller une pi√®ce d√©j√† pos√©e
      el.addEventListener('dblclick', () => {
        if (el.classList.contains('locked')) {
          el.classList.remove('locked');
          const prev = el.dataset.posIdx; if (prev && occupied.get(+prev) === el) occupied.delete(+prev);
        }
      });
    }

    function returnToTray(el) { trayInner.appendChild(el); const bleed = (el.offsetWidth - cell) / 2; const x = 12 + Math.random() * Math.max(12, (tray.clientWidth - (cell + 2 * bleed) - 36)); const y = 12 + Math.random() * Math.max(12, (tray.clientHeight * 2 - (cell + 2 * bleed) - 36)); el.style.left = x + 'px'; el.style.top = y + 'px'; el.dataset.posIdx = ''; }

    function updateProgress() { countEl.textContent = String(placedCount); /* could add confetti */ }

    function shufflePieces() { pieces.forEach(p => { p.classList.remove('locked'); p.dataset.posIdx = ''; }); occupied.clear(); placedCount = 0; updateProgress(); pieces.forEach(p => returnToTray(p)); }

    fileInput.addEventListener('change', e => { const file = e.target.files?.[0]; if (!file) return; if (imgURL) URL.revokeObjectURL(imgURL); imgURL = URL.createObjectURL(file); loadImageAndBuild(imgURL); });
    function loadImageAndBuild(url) { const im = new Image(); im.onload = () => { preview.style.backgroundImage = `url('${url}')`; rebuild(url); }; im.src = url; }

    function rebuild(url) { pieces.forEach(p => p.remove()); pieces = []; occupied.clear(); placedCount = 0; updateProgress(); setMetrics(); genEdges(); for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) createPiece(r, c, url); }

    window.addEventListener('resize', () => { setMetrics(); /* keep already-placed aligned */ const bleedCalc = p => (p.offsetWidth - cell) / 2; pieces.forEach(p => { if (p.classList.contains('locked')) { const idx = +p.dataset.posIdx; if (Number.isFinite(idx)) { const row = Math.floor(idx / COLS), col = idx % COLS; const bleed = bleedCalc(p); p.style.left = (col * cell - bleed) + 'px'; p.style.top = (row * cell - bleed) + 'px'; board.appendChild(p); } } }); });

    (function init() { imgURL = defaultImage; preview.style.backgroundImage = `url('${imgURL}')`; setMetrics(); genEdges(); rebuild(imgURL); })();

    shuffleBtn.addEventListener('click', shufflePieces);
    autoLockToggle.addEventListener('change', () => { autoLock = autoLockToggle.checked; });
  </script>
</body>

</html>